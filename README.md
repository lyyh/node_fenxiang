## node 分享
### 让我们认识node
基于事件驱动、非阻塞IO的异步架构，使用了Chrome V8引擎(javascript引擎，提供javascript解析执行环境)。node中，javascript可以访问读取本地文件，搭建webSocket服务器端，可以连接数据库，也可以如Web Workers 一样玩转多进程。Node打破了过去javascript只能运行在浏览器中运行的局面。大大降低了前后端转化所需要的代价。  
### 目前我用到的node
web服务器  
爬虫  
### node概念 基于事件驱动、异步机制、单线程  
#### 事件驱动
事件驱动，简单的定义就是:事件驱动编程通过事件或者状态的变化来进行应用程序的流程控制。一般通过事件监听实现，一旦事件被检测到（即状态改变）则调用相应的回调函数。   

node的事件驱动得益于"事件循环机制"(Event Loop)。主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，不存在等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。

Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。  
Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。  
Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。  
Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.    
#### 异步IO
异步调用IO，将请求处理交给node端(第三方模块)，将请求得到的数据返回给回调函数，回调函数再对数据进行下一步逻辑运算。
#### 单线程
无法共享任何状态，最大的好处就是不用考虑多线程切换带来的系统性能上的开销。  
弱点:  
1. 无法利用多核CPU  
2. 错误会引起整个应用退出，应用的健壮性值得考验  
3. 大量计算会占用CUP导致无法继续调用异步IO  
#### 应用场景
IO密集型应用：主要在于Node利用事件循环处理能力  
不擅长CUP密集型业务:大量的计算
### commonjs模块 规范
commonjs加载模块规范是同步的，由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用    
方式:
require 
exports 
module.exports 
### 搭建一个node服务器
http 模块
### 获取参数的方式
url.parse(request.url,true)  
querystring.parse()
### 路由
### epxress
